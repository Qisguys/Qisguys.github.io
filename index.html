<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<blockquote></blockquote>
<blockquote>S.No	 Question			Option1		Option2		Option3		Option4		Correct Answer	<br><br>
	1	What is the time complexity of a linear search algorithm?	<br>	<b>1)</b>	  O(1)	<b>2)</b>	 O(log n)	<b>3)</b>	O(n)	<b>4)</b>	    O(n^2)	<b>Ans</b>	3	<br><br>
	2	Which sorting algorithm has the best worst-case time complexity?	<br>	<b>1)</b>	 Bubble Sort	<b>2)</b>	   Merge Sort	<b>3)</b>	Insertion Sort	<b>4)</b>	Selection Sort	<b>Ans</b>	2	<br><br>
	3	    What is the worst-case time complexity of the Quick Sort algorithm?	<br>	<b>1)</b>	O(n)	<b>2)</b>	  O(n log n)	<b>3)</b>	 O(n^2)	<b>4)</b>	   O(log n)	<b>Ans</b>	2	<br><br>
	4	What is the time complexity of the Binary Search algorithm?	<br>	<b>1)</b>	O(n)	<b>2)</b>	  O(n log n)	<b>3)</b>	 O(n^2)	<b>4)</b>	   O(log n)	<b>Ans</b>	4	<br><br>
	5	   What is the time complexity of the worst-case scenario for the Bubble Sort algorithm?	<br>	<b>1)</b>	O(n)	<b>2)</b>	  O(n log n)	<b>3)</b>	 O(n^2)	<b>4)</b>	   O(log n)	<b>Ans</b>	3	<br><br>
	6	    What type of algorithm is used to sort elements by comparing and swapping adjacent elements?	<br>	<b>1)</b>	   Greedy Algorithm	<b>2)</b>	     Divide and Conquer	<b>3)</b>	    Dynamic Programming	<b>4)</b>	Sorting Algorithm	<b>Ans</b>	4	<br><br>
	7	Which type of algorithm is used to find the solution to a problem by breaking it down into subproblems, solving the subproblems, and combining their solutions?	<br>	<b>1)</b>	 Greedy Algorithm	<b>2)</b>	a)      Divide and Conquer	<b>3)</b>	a)      Dynamic Programming	<b>4)</b>	a)      Brute Force Algorithm	<b>Ans</b>	2	<br><br>
	8	What does Big O notation (O()) represent in terms of algorithm analysis?	<br>	<b>1)</b>	  Best-case time complexity	<b>2)</b>	  Worst-case time complexity	<b>3)</b>	    Average-case time complexity	<b>4)</b>	Lower bound of time complexity	<b>Ans</b>	2	<br><br>
	9	  Which of the following statements about Big O notation is true?	<br>	<b>1)</b>	  It provides an upper bound on the running time of an algorithm.	<b>2)</b>	It provides an exact running time of an algorithm	<b>3)</b>	It describes the best-case performance of an algorithm	<b>4)</b>	It is used to denote the lower bound of an algorithm	<b>Ans</b>	1	<br><br>
	10	What is the time complexity of an algorithm with O(log n) time complexity?	<br>	<b>1)</b>	  Constant time	<b>2)</b>	  Linear time	<b>3)</b>	  Logarithmic time	<b>4)</b>	  Quadratic time	<b>Ans</b>	3	<br><br>
	11	 What is the time complexity of an algorithm with O(n^2) time complexity?	<br>	<b>1)</b>	  Constant time	<b>2)</b>	  Linear time	<b>3)</b>	  Logarithmic time	<b>4)</b>	  Quadratic time	<b>Ans</b>	4	<br><br>
	12	Which of the following notations represents the best-case scenario of an algorithm's time complexity?	<br>	<b>1)</b>	   O(n)	<b>2)</b>	  Θ(n)	<b>3)</b>	Ω(n)	<b>4)</b>	  O(1)	<b>Ans</b>	4	<br><br>
	13	    What does Θ notation (Theta notation) represent in terms of algorithm analysis?	<br>	<b>1)</b>	    Average-case time complexity	<b>2)</b>	 Worst-case time complexity	<b>3)</b>	Both best-case and worst-case time complexity	<b>4)</b>	Exact mathematical description of running time	<b>Ans</b>	3	<br><br>
	14	Which of the following is true about Ω notation (Omega notation)?	<br>	<b>1)</b>	It provides an upper bound on the running time of an algorithm.	<b>2)</b>	  It provides a lower bound on the running time of an algorithm.	<b>3)</b>	    It provides an exact running time of an algorithm.	<b>4)</b>	    It is used for average-case analysis.	<b>Ans</b>	2	<br><br>
	15	Which notation is used to represent the average-case time complexity of an algorithm?	<br>	<b>1)</b>	  O()	<b>2)</b>	 Θ()	<b>3)</b>	 Ω()	<b>4)</b>	None of the above	<b>Ans</b>	2	<br><br>
	16	 Which of the following time complexities represents a more efficient algorithm?	<br>	<b>1)</b>	    O(n)	<b>2)</b>	  O(n^2)	<b>3)</b>	     O(log n)	<b>4)</b>	     O(2^n)	<b>Ans</b>	3	<br><br>
	17	 What does the notation o() (little o) represent in terms of asymptotic analysis?	<br>	<b>1)</b>	Upper bound	<b>2)</b>	   Lower bound	<b>3)</b>	  Tight bound	<b>4)</b>	Strictly less than	<b>Ans</b>	4	<br><br>
	18	Which of the following notations denotes the upper bound on the running time of an algorithm in the worst-case scenario	<br>	<b>1)</b>	     O()	<b>2)</b>	     Θ()	<b>3)</b>	  Ω()	<b>4)</b>	  o()	<b>Ans</b>	4	<br><br>
	19	If an algorithm has a time complexity of O(1), what can be said about its efficiency?	<br>	<b>1)</b>	It is very efficient	<b>2)</b>	  It has a constant running time.	<b>3)</b>	 It is not efficient.	<b>4)</b>	 It has a logarithmic running time.	<b>Ans</b>	2	<br><br>
	20	 Which notation is used to denote the lower bound of an algorithm's time complexity?	<br>	<b>1)</b>	 O()	<b>2)</b>	Θ()	<b>3)</b>	   Ω()	<b>4)</b>	    o()	<b>Ans</b>	3	<br><br>
	21	 What is the time complexity of an algorithm with Ω(n^2) time complexity?	<br>	<b>1)</b>	 Constant time	<b>2)</b>	 Linear time	<b>3)</b>	Quadratic time	<b>4)</b>	 Logarithmic time	<b>Ans</b>	3	<br><br>
	22	  Which of the following is true about Omega notation (Ω)?	<br>	<b>1)</b>	 It provides an upper bound on the running time of an algorithm.	<b>2)</b>	  It provides a lower bound on the running time of an algorithm.	<b>3)</b>	 It provides an exact running time of an algorithm.	<b>4)</b>	 It is used for average-case analysis.	<b>Ans</b>	2	<br><br>
	23	 Which of the following notations represents a tight bound on an algorithm's time complexity?	<br>	<b>1)</b>	      O()	<b>2)</b>	Θ()	<b>3)</b>	  Ω()	<b>4)</b>	o()	<b>Ans</b>	2	<br><br>
	24	  If an algorithm has a time complexity of O(n log n), which of the following statements is true?	<br>	<b>1)</b>	It is less efficient than an algorithm with O(n^2) time complexity.	<b>2)</b>	It is more efficient than an algorithm with O(n^2) time complexity.	<b>3)</b>	 Both have the same efficiency.	<b>4)</b>	  The efficiency cannot be determined based on this information.	<b>Ans</b>	2	<br><br>
	25	"	Which notation is used to represent the upper bound on the running time of an algorithm in the best-case scenario?"	<br>	<b>1)</b>	  O()	<b>2)</b>	Θ()	<b>3)</b>	     Ω()	<b>4)</b>	 o()	<b>Ans</b>	1	<br><br>
	26	 What does the notation ω() (omega) represent in terms of asymptotic analysis?	<br>	<b>1)</b>	 Upper bound	<b>2)</b>	 Lower bound	<b>3)</b>	 Tight bound	<b>4)</b>	 Strictly greater than	<b>Ans</b>	2	<br><br>
	27	  Which of the following notations is used to represent the best-case time complexity of an algorithm?	<br>	<b>1)</b>	  O()	<b>2)</b>	  Θ()	<b>3)</b>	Ω()	<b>4)</b>	o()	<b>Ans</b>	4	<br><br>
	28	     What is a data structure?	<br>	<b>1)</b>	   A way to store data in a computer's memory	<b>2)</b>	  A way to represent real-world objects in code	<b>3)</b>	     A way to organize and manage data for efficient access and modification	<b>4)</b>	   All of the above	<b>Ans</b>	3	<br><br>
	29	Which of the following is an example of a primitive data structure?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Integers 	<b>4)</b>	Trees	<b>Ans</b>	3	<br><br>
	30	  What is the primary goal of a data structure?	<br>	<b>1)</b>	Efficient storage of data	<b>2)</b>	 Efficient retrieval of data	<b>3)</b>	 Both a and b	<b>4)</b>	 None of the above	<b>Ans</b>	3	<br><br>
	31	Which of the following data structures does not have a linear structure?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Trees	<b>4)</b>	Stacks	<b>Ans</b>	3	<br><br>
	32	 Which data structure allows elements to be accessed in constant time using an index?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Stacks	<b>4)</b>	Queue	<b>Ans</b>	1	<br><br>
	33	     Which type of data structure follows the Last-In-First-Out (LIFO) principle?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Stacks	<b>4)</b>	Queue	<b>Ans</b>	3	<br><br>
	34	Which type of data structure follows the First-In-First-Out (FIFO) principle	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Stacks	<b>4)</b>	Queue	<b>Ans</b>	4	<br><br>
	35	Which data structure allows elements to be added and removed from both ends?	<br>	<b>1)</b>	    Stack	<b>2)</b>	 Queue	<b>3)</b>	 Deque (Double-Ended Queue)	<b>4)</b>	 Linked List	<b>Ans</b>	3	<br><br>
	36	 What is the main characteristic of a tree data structure?	<br>	<b>1)</b>	 It is a hierarchical structure with a root node and child nodes.	<b>2)</b>	It is a linear structure with a single path from one node to another.	<b>3)</b>	It is a collection of elements with no specific organization.	<b>4)</b>	 It allows elements to be accessed using an index.	<b>Ans</b>	1	<br><br>
	37	 Which data structure allows for efficient search, insert, and delete operations with a dynamic set of elements?	<br>	<b>1)</b>	 Arrays	<b>2)</b>	Linked Lists	<b>3)</b>	Hash Tables	<b>4)</b>	Trees	<b>Ans</b>	3	<br><br>
	38	Which type of data structure is used for representing a graph?	<br>	<b>1)</b>	 Arrays	<b>2)</b>	Linked Lists	<b>3)</b>	Graphs	<b>4)</b>	Stacks	<b>Ans</b>	3	<br><br>
	39	 In which type of data structure are elements stored in a key-value pair format?	<br>	<b>1)</b>	 Arrays	<b>2)</b>	Linked Lists	<b>3)</b>	Hash Tables	<b>4)</b>	   Trees	<b>Ans</b>	3	<br><br>
	40	   Which data structure allows for elements to be accessed in logarithmic time through a sorted collection?	<br>	<b>1)</b>	    Arrays	<b>2)</b>	   Binary Search Trees	<b>3)</b>	  Linked Lists	<b>4)</b>	Stacks	<b>Ans</b>	2	<br><br>
	41	    Which type of data structure is used for representing a collection of elements where each element points to the next one in the sequence?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Stacks	<b>4)</b>	Queue	<b>Ans</b>	2	<br><br>
	42	   Which data structure is often used for efficient searching and retrieval of data with the help of keys?	<br>	<b>1)</b>	Arrays	<b>2)</b>	Linked lists	<b>3)</b>	Hash Tables	<b>4)</b>	Stacks	<b>Ans</b>	3	<br><br>
	43	    What is recursion in computer science?	<br>	<b>1)</b>	A technique where a function calls itself.	<b>2)</b>	A technique where a function is called by another function.	<b>3)</b>	  A technique to optimize code execution.	<b>4)</b>	A technique to prevent stack overflow	<b>Ans</b>	1	<br><br>
	44	     In recursion, what is the base case?	<br>	<b>1)</b>	The case where the function calls itself.	<b>2)</b>	  The case where the function returns a value without making further recursive calls.	<b>3)</b>	 The case where the function has multiple base cases.	<b>4)</b>	 The case where the function returns an error.	<b>Ans</b>	2	<br><br>
	45	Which of the following is NOT a necessary condition for a recursive function?	<br>	<b>1)</b>	  Base case(s)	<b>2)</b>	 Recursive case(s)	<b>3)</b>	   A loop	<b>4)</b>	   Stopping condition	<b>Ans</b>	3	<br><br>
	46	 What happens if a recursive function does not have a base case?	<br>	<b>1)</b>	The function will run indefinitely and may cause a stack overflow.	<b>2)</b>	The function will terminate early	<b>3)</b>	The function will return an error.	<b>4)</b>	The function will return a random value.	<b>Ans</b>	1	<br><br>
	47	   What is the main advantage of using recursion in programming?	<br>	<b>1)</b>	  It leads to faster execution.	<b>2)</b>	 It simplifies code and problem-solving.	<b>3)</b>	 It requires less memory.	<b>4)</b>	It eliminates the need for loops.	<b>Ans</b>	2	<br><br>
	48	What is tail recursion?	<br>	<b>1)</b>	A type of recursion where the recursive call is the last operation in the function.	<b>2)</b>	A type of recursion where the function returns a value without making further recursive calls.	<b>3)</b>	A type of recursion that involves multiple base cases.	<b>4)</b>	A type of recursion that leads to stack overflow.	<b>Ans</b>	1	<br><br>
	49	 In tail recursion, which optimization can be applied by compilers?	<br>	<b>1)</b>	   Memoization	<b>2)</b>	 Tail Call Optimization	<b>3)</b>	Dynamic Programming	<b>4)</b>	Greedy Algorithm	<b>Ans</b>	2	<br><br>
	50	What is indirect recursion?	<br>	<b>1)</b>	  A type of recursion where a function calls itself indirectly through another function.	<b>2)</b>	A type of recursion that involves multiple base cases.	<b>3)</b>	A type of recursion where the function calls itself multiple times	<b>4)</b>	   A type of recursion where the function returns a value without making further recursive calls.	<b>Ans</b>	1	<br><br>
	51	What is mutual recursion?	<br>	<b>1)</b>	 A type of recursion where two or more functions call each other in a cycle.	<b>2)</b>	A type of recursion that involves multiple base cases.	<b>3)</b>	 A type of recursion that leads to stack overflow.	<b>4)</b>	  A type of recursion where the function calls itself multiple times.	<b>Ans</b>	1	<br><br>
	52	  Which type of recursion is generally more memory-intensive?	<br>	<b>1)</b>	Tail recursion	<b>2)</b>	     Head recursion	<b>3)</b>	Both use the same amount of memory	<b>4)</b>	It depends on the specific implementation	<b>Ans</b>	2	<br><br>
	53	Which algorithm uses recursion to solve the Tower of Hanoi problem?	<br>	<b>1)</b>	 Insertion Sort	<b>2)</b>	Merge Sort	<b>3)</b>	Quick Sort	<b>4)</b>	None of the above	<b>Ans</b>	2	<br><br>
	54	 In the Tower of Hanoi problem with n disks, what is the minimum number of moves required to solve it?	<br>	<b>1)</b>	   2^n - 1	<b>2)</b>	n	<b>3)</b>	2n	<b>4)</b>	n^2	<b>Ans</b>	1	<br><br>
	55	  If you have 3 disks in the Tower of Hanoi problem, how many moves are needed to solve it?	<br>	<b>1)</b>	3	<b>2)</b>	7	<b>3)</b>	15	<b>4)</b>	8	<b>Ans</b>	2	<br><br>
	56	   What is the maximum number of moves required to solve the Tower of Hanoi problem with 4 disks?	<br>	<b>1)</b>	8	<b>2)</b>	15	<b>3)</b>	16	<b>4)</b>	7	<b>Ans</b>	1	<br><br>
	57	 If you have 5 disks in the Tower of Hanoi problem, how many moves are needed to solve it?	<br>	<b>1)</b>	31	<b>2)</b>	25	<b>3)</b>	63	<b>4)</b>	32	<b>Ans</b>	1	<br><br>
	58	 In the Tower of Hanoi problem, what is the rule regarding placing a larger disk on top of a smaller disk?	<br>	<b>1)</b>	It is allowed	<b>2)</b>	It is not allowed	<b>3)</b>	It depends on the specific problem	<b>4)</b>	It doesn't matter	<b>Ans</b>	2	<br><br>
	59	    What is the Fibonacci sequence?	<br>	<b>1)</b>	A sequence of numbers where each number is the sum of the two preceding ones.	<b>2)</b>	A sequence of prime numbers	<b>3)</b>	A sequence of odd numbers	<b>4)</b>	  A sequence of random numbers.	<b>Ans</b>	1	<br><br>
	60	   In the Fibonacci sequence, what are the first two numbers?	<br>	<b>1)</b>	0,1	<b>2)</b>	1,2	<b>3)</b>	1,0	<b>4)</b>	2,1	<b>Ans</b>	1	<br><br>
	61	     What is the recursive definition of the Fibonacci sequence?	<br>	<b>1)</b>	fib(n) = fib(n-1) + fib(n-2) for n > 1, with base cases fib(0) = 0 and fib(1) = 1.	<b>2)</b>	 fib(n) = fib(n+1) + fib(n+2) for n > 1, with base cases fib(0) = 1 and fib(1) = 2.	<b>3)</b>	   fib(n) = n * fib(n-1) for n > 1, with base case fib(0) = 0.	<b>4)</b>	fib(n) = n * fib(n-1) for n > 1, with base case fib(0) = 1.	<b>Ans</b>	1	<br><br>
	62	 What is the time complexity of a naive recursive approach to compute Fibonacci numbers?	<br>	<b>1)</b>	O(n)	<b>2)</b>	 O(2^n)	<b>3)</b>	  O(log n)	<b>4)</b>	O(n^2)	<b>Ans</b>	2	<br><br>
	63	  What is the GCD (Greatest Common Divisor) of 12 and 18?	<br>	<b>1)</b>	2	<b>2)</b>	3	<b>3)</b>	4	<b>4)</b>	6	<b>Ans</b>	2	<br><br>
	64	What is the recursive definition of the GCD (Greatest Common Divisor)?	<br>	<b>1)</b>	gcd(a, b) = gcd(a-b, b) for a > b, with base case gcd(a, 0) = a.	<b>2)</b>	gcd(a, b) = gcd(a, b-a) for a > b, with base case gcd(0, b) = b.	<b>3)</b>	gcd(a, b) = gcd(b, a-b) for a > b, with base case gcd(a, 0) = a.	<b>4)</b>	gcd(a, b) = gcd(b, a%b) for b > 0, with base case gcd(a, 0) = a.	<b>Ans</b>	4	<br><br>
	65	    What is the GCD of two prime numbers?	<br>	<b>1)</b>	1	<b>2)</b>	  The smaller of the two prime numbers	<b>3)</b>	The larger of the two prime numbers	<b>4)</b>	None of the above	<b>Ans</b>	1	<br><br>
	66	What is the GCD of any number and 0?	<br>	<b>1)</b>	  The number itself	<b>2)</b>	0	<b>3)</b>	1	<b>4)</b>	Undefined	<b>Ans</b>	1	<br><br>
	67	What is the time complexity of the Euclidean algorithm for finding the GCD?	<br>	<b>1)</b>	O(n)	<b>2)</b>	  O(log n)	<b>3)</b>	O(n log n)	<b>4)</b>	 O(1)	<b>Ans</b>	2	<br><br>
	68	A step by step instruction used to solve a problem is known as *	<br>	<b>1)</b>	List	<b>2)</b>	An Algorithm	<b>3)</b>	Sequential structure	<b>4)</b>	Plan	<b>Ans</b>	2	<br><br>
	69	.…………is used to describe the algorithm,in less formal language	<br>	<b>1)</b>	Natural languages	<b>2)</b>	pseudo code	<b>3)</b>	Cannot be defined	<b>4)</b>	None	<b>Ans</b>	2	<br><br>
	70	Which of the following is a pictorial representation of an algorithm?	<br>	<b>1)</b>	Natural languages	<b>2)</b>	pseudo code	<b>3)</b>	Flow chart	<b>4)</b>	None	<b>Ans</b>	3	<br><br>
	71	When an algorithm is written in the form of a programming language, it becomes a _________	<br>	<b>1)</b>	pseudo code	<b>2)</b>	Flow chart	<b>3)</b>	Program	<b>4)</b>	Syntax	<b>Ans</b>	3	<br><br>
	72	What is an Algorithm?	<br>	<b>1)</b>	A flowchart	<b>2)</b>	Step by step instructions used to solve a problem	<b>3)</b>	A decision	<b>4)</b>	A Pseudocode	<b>Ans</b>	2	<br><br>
	73	Two main measures for the efficiency of an algorithm are	<br>	<b>1)</b>	processor and memory	<b>2)</b>	data and space	<b>3)</b>	time and space	<b>4)</b>	complexity and capacity	<b>Ans</b>	3	<br><br>
	74	Time factor when determining the efficiency of algorithm is measured by	<br>	<b>1)</b>	counting micro seconds	<b>2)</b>	counting micro seconds	<b>3)</b>	counting the no of key operations	<b>4)</b>	counting the kilobytes of algorithm	<b>Ans</b>	3	<br><br>
	75	Space factor when determining the efficiency of algorithm is measured by	<br>	<b>1)</b>	Counting the max memory needed by the algorithm	<b>2)</b>	Counting the min memory needed by the algorithm	<b>3)</b>	Countnig the avg memory needed by the algorithm	<b>4)</b>	Counting the max disk space needed by the algorithm	<b>Ans</b>	2	<br><br>
	76	Which of the following cases does not exist in complexity theory.	<br>	<b>1)</b>	Best case	<b>2)</b>	Average case	<b>3)</b>	worst case	<b>4)</b>	null case	<b>Ans</b>	4	<br><br>
	77	The big Oh notation defines ---- of an algorithm	<br>	<b>1)</b>	upper bound	<b>2)</b>	lower bound	<b>3)</b>	BOTH A and B	<b>4)</b>	None of the above	<b>Ans</b>	1	<br><br>
	78	What is a singly linked list?	<br>	<b>1)</b>	a) A data structure where elements are stored in contiguous memory locations.	<b>2)</b>	b) A linear collection of nodes, where each node points to the next one.	<b>3)</b>	c) A data structure that allows elements to be accessed using an index.	<b>4)</b>	d) A data structure that allows elements to be accessed in constant time.	<b>Ans</b>	1	<br><br>
	79	   In a singly linked list, what is the first node called?	<br>	<b>1)</b>	a) Root node	<b>2)</b>	b) Head node	<b>3)</b>	c) Tail node	<b>4)</b>	d) Leaf node	<b>Ans</b>	2	<br><br>
	80	What is the advantage of using a linked list over an array?	<br>	<b>1)</b>	a) Linked lists have better cache locality.	<b>2)</b>	b) Linked lists have constant-time access to any element.	<b>3)</b>	c) Linked lists can dynamically resize.	<b>4)</b>	d) Linked lists have better space efficiency.	<b>Ans</b>	3	<br><br>
	81	What is the time complexity for searching an element in an unsorted singly linked list?	<br>	<b>1)</b>	a) O(1)	<b>2)</b>	b) O(n)	<b>3)</b>	c) O(log n)	<b>4)</b>	d) O(n^2)	<b>Ans</b>	2	<br><br>
	82	In a singly linked list, what does the last node point to?	<br>	<b>1)</b>	a) Null	<b>2)</b>	b) The first node	<b>3)</b>	c) The largest value node	<b>4)</b>	d) The head node	<b>Ans</b>	1	<br><br>
	83	 What is the time complexity of inserting a node at the beginning of a singly linked list?	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	1	<br><br>
	84	What is the time complexity of deleting the first node from a singly linked list?	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	1	<br><br>
	85	What is the time complexity of reversing a singly linked list?	<br>	<b>1)</b>	a. O(n)	<b>2)</b>	b. O(log n)	<b>3)</b>	c. O(n^2)	<b>4)</b>	d. O(1)	<b>Ans</b>	1	<br><br>
	86	 What is the time complexity of finding the length of a singly linked list?	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	2	<br><br>
	87	 What is the time complexity of searching for a value in an unsorted singly linked list?	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	2	<br><br>
	88	What is the time complexity of merging two sorted singly linked lists?	<br>	<b>1)</b>	a. O(n)	<b>2)</b>	b. O(log n)	<b>3)</b>	c. O(n^2)	<b>4)</b>	d. O(1)	<b>Ans</b>	1	<br><br>
	89	 What is the time complexity of finding the middle node of a singly linked list?	<br>	<b>1)</b>	a. O(n)	<b>2)</b>	b. O(log n)	<b>3)</b>	c. O(n^2)	<b>4)</b>	d. O(1)	<b>Ans</b>	1	<br><br>
	90	"Consider the following C pseudo code for inserting a node at the beginning of a singly linked list:
	
	void InsertBeginning(int value) {
	Node *newNode = CreateNode(value);
	newNode->next = head;
	head = newNode;
	}
	What is the time complexity of this insertion operation?
	"	<br>	<b>1)</b>	a) O(1)	<b>2)</b>	b) O(n)	<b>3)</b>	c) O(log n)	<b>4)</b>	d) O(n^2)	<b>Ans</b>	1	<br><br>
	91	"14. Consider the following C pseudo code for inserting a node after a given node in a singly linked list:
	
	
	void InsertAfter(Node *node, int value) {
	if (node != NULL) {
	Node *newNode = CreateNode(value);
	newNode->next = node->next;
	node->next = newNode;
	}
	}
	What is the purpose of the `if (node != NULL)` condition?
	"	<br>	<b>1)</b>	a. It checks if the linked list is empty.	<b>2)</b>	b. It ensures that the given node is not the last node in the list.	<b>3)</b>	c. It checks if the given node exists.	<b>4)</b>	d. It checks if the new node is not null	<b>Ans</b>	3	<br><br>
	92	"15. Consider the following C pseudo code for inserting a node at the end of a singly linked list:
	
	void InsertEnd(int value) {
	Node *newNode = CreateNode(value);
	if (head == NULL) {
	head = newNode;
	} else {
	Node *current = head;
	while (current->next != NULL) {
	current = current->next;
	}
	current->next = newNode;
	}
	}
	What is the time complexity of this insertion operation?
	"	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	1	<br><br>
	93	"16. Consider the following C pseudo code for inserting a node at a specific position in a singly linked list:
	
	void InsertAtPosition(int position, int value) {
	if (position == 0) {
	InsertBeginning(value);
	} else {
	Node *newNode = CreateNode(value);
	Node *current = head;
	for (int i = 0; i < position - 1; i++) {
	if (current != NULL) {
	current = current->next;
	}
	}
	if (current != NULL) {
	newNode->next = current->next;
	current->next = newNode;
	}
	}
	}
	What is the time complexity of this insertion operation?
	"	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	2	<br><br>
	94	"17. Consider the following C pseudo code for deleting the first node from a singly linked list:
	
	void DeleteFirst() {
	if (head != NULL) {
	Node *temp = head;
	head = head->next;
	free(temp);
	}
	}
	What does `free(temp)` do?
	"	<br>	<b>1)</b>	a. It deallocates the memory occupied by the first node.	<b>2)</b>	b. It deletes the first node.	<b>3)</b>	c. It moves the head pointer to the next node.	<b>4)</b>	d. It frees the memory of the head pointer.	<b>Ans</b>	1	<br><br>
	95	"18. Consider the following C pseudo code for deleting the last node from a singly linked list:
	
	void DeleteLast() {
	if (head != NULL) {
	if (head->next == NULL) {
	free(head);
	head = NULL;
	} else {
	Node *current = head;
	while (current->next->next != NULL) {
	current = current->next;
	}
	Node *temp = current->next;
	current->next = NULL;
	free(temp);
	}
	}
	}
	What is the purpose of the condition `if (head->next == NULL)`?
	"	<br>	<b>1)</b>	a. It checks if the linked list contains only one node.	<b>2)</b>	b. It checks if the linked list is empty.	<b>3)</b>	c. It ensures that the last node is being deleted.	<b>4)</b>	d. It checks if the head pointer is not null.	<b>Ans</b>	1	<br><br>
	96	"19. Consider the following C pseudo code for deleting a node with a specific value from a singly linked list:
	
	void DeleteByValue(int value) {
	if (head != NULL) {
	if (head->value == value) {
	Node *temp = head;
	head = head->next;
	free(temp);
	} else { 
	Node *current = head;
	while (current->next != NULL && current->next->value != value) {
	current = current->next;
	}
	if (current->next != NULL) {
	Node *temp = current->next;
	current->next = current->next->next;
	free(temp);
	}
	}
	}
	}
	What is the time complexity of this deletion operation?
	"	<br>	<b>1)</b>	a. O(1)	<b>2)</b>	b. O(n)	<b>3)</b>	c. O(log n)	<b>4)</b>	d. O(n^2)	<b>Ans</b>	2	<br><br>
	97	"20. Consider the following C pseudo code for traversing a singly linked list:
	
	void TraverseList() {
	Node *current = head;
	while (current != NULL) {
	printf(""%d "", current->value);
	current = current->next;
	}
	}
	What does the `printf(""%d "", current->value);` line do?
	"	<br>	<b>1)</b>	a. It prints the value of the current node.	<b>2)</b>	b. It prints the address of the current node.	<b>3)</b>	c. It prints the value of the next node.	<b>4)</b>	d. It prints the address of the next node.	<b>Ans</b>	1	<br><br>
	98	"21. Consider the following C pseudo code for finding the middle node of a singly linked list:
	
	int FindMiddle() {
	Node *slow = head;
	Node *fast = head;
	while (fast != NULL && fast->next != NULL) {
	slow = slow->next;
	fast = fast->next->next;
	}
	return slow->value;
	}
	What does this pseudo code do?
	"	<br>	<b>1)</b>	a. It finds the value of the middle node in the linked list.	<b>2)</b>	b. It finds the position of the middle node in the linked list.	<b>3)</b>	c. It determines if the linked list is circular.	<b>4)</b>	d. It counts the number of nodes in the linked list.	<b>Ans</b>	1	<br><br>
	99	"22. Consider the following C pseudo code for finding the Nth node from the end of a singly linked list:
	
	int FindNthFromEnd(int N) {
	Node *mainPointer = head;
	Node *referencePointer = head;
	int count = 0;
	while (count < N) {
	if (referencePointer != NULL) {
	referencePointer = referencePointer->next;
	} else {
	printf(""N is greater than the number of nodes in the list."");
	return -1;
	}
	count++;
	}
	
	
	while (referencePointer != NULL) {
	mainPointer = mainPointer->next;
	referencePointer = referencePointer->next;
	}
	return mainPointer->value;
	}
	What does this pseudo code do?
	"	<br>	<b>1)</b>	a. It finds the Nth node from the end of the linked list.	<b>2)</b>	b. It finds the value of the middle node in the linked list.	<b>3)</b>	 c. It reverses the linked list.	<b>4)</b>	d. It counts the number of nodes in the linked list.	<b>Ans</b>	1	<br><br>
	100	23. In a polynomial expression \(P(x) = 3x^3 + 2x^2 - 5x + 1\), what is the degree of the polynomial?	<br>	<b>1)</b>	a. 3	<b>2)</b>	b. 2	<b>3)</b>	c. 1	<b>4)</b>	d. 0	<b>Ans</b>	3	<br><br>
	101	24. Consider the polynomial expression \(P(x) = 2x^3 - 3x^2 + 4x - 1\). What would be the linked list representation of this polynomial?	<br>	<b>1)</b>	a) 2 -> 3 -> 4 -> 1	<b>2)</b>	b) 2 -> -3 -> 4 -> -1	<b>3)</b>	c) 1 -> 4 -> -3 -> 2	<b>4)</b>	d) -1 -> 4 -> -3 -> 2	<b>Ans</b>	2	<br><br>
	102	25. In a linked list representation of a polynomial, each node contains:	<br>	<b>1)</b>	a) Coefficient and Exponent	<b>2)</b>	b) Coefficient only	<b>3)</b>	c) Exponent only	<b>4)</b>	d) Constant value	<b>Ans</b>	1	<br><br>
	103	"26. Consider the following C code snippet to create a node for a polynomial:
	 
	typedef struct Node {
	int coeff;
	int exp;
	struct Node* next;
	} Node;
	
	 
		What does `coeff` and `exp` represent in this structure?
	"	<br>	<b>1)</b>	a) Coefficient and Exponent of a term in a polynomial	<b>2)</b>	b) Coefficient of a term in a polynomial	<b>3)</b>	c) Exponent of a term in a polynomial	<b>4)</b>	d) Constant value	<b>Ans</b>	1	<br><br>
	104	27. In a sparse matrix representation using linked lists, how are non-zero elements stored?	<br>	<b>1)</b>	a) Each node stores the row, column, and value of a non-zero element.	<b>2)</b>	b) Each node stores only the value of a non-zero element.	<b>3)</b>	c) Each node stores the row and column of a non-zero element.	<b>4)</b>	d) Each node stores the column of a non-zero element.	<b>Ans</b>	1	<br><br>
	105	"28. Consider the following C code snippet to create a node for a sparse matrix:
	typedef struct Node {
	int row;
	int col;
	int value;
	struct Node* next;
	} Node;
	 
		 What do `row`, `col`, and `value` represent in this structure?
	"	<br>	<b>1)</b>	a) Row, column, and value of a non-zero element in a matrix	<b>2)</b>	b) Row of a non-zero element, column of a non-zero element, and value of a non-zero element	<b>3)</b>	c) Row and column of a non-zero element in a matrix	<b>4)</b>	d) Value of a non-zero element in a matrix	<b>Ans</b>	1	<br><br>
	106	In a linked list representation of a sparse matrix, what is the advantage of using this method for storing sparse matrices?	<br>	<b>1)</b>	a) Efficient storage for matrices with many non-zero elements	<b>2)</b>	b) Efficient storage for small matrices	<b>3)</b>	c) Faster multiplication operations	<b>4)</b>	"d) Faster addition operations
	 
	"	<b>Ans</b>	1	<br><br>
	107	30. In a linked list representation of a sparse matrix, what does a node with `row = -1` and `col = -1` signify?	<br>	<b>1)</b>	a) End of the linked list	<b>2)</b>	b) It represents a non-zero element in the matrix	<b>3)</b>	c) It represents a zero element in the matrix	<b>4)</b>	d) It represents the first element in the matrix	<b>Ans</b>	3	<br><br>
	108	"30. Consider a 3x3 sparse matrix with the following non-zero elements:
	 
	   2  0  0
	   0  5  0
	   0  0  3
		  What would be the linked list representation of this sparse matrix?
	"	<br>	<b>1)</b>	a) (2, 0, 2) -> (1, 1, 5) -> (2, 2, 3)	<b>2)</b>	b) (0, 0, 2) -> (1, 1, 5) -> (2, 2, 3)	<b>3)</b>	c) (0, 0, 2) -> (1, 1, 5) -> (2, 2, 3) -> (-1, -1, -1)	<b>4)</b>	"d) (2, 2, 3) -> (1, 1, 5) -> (0, 0, 2)
	 
	"	<b>Ans</b>	3	<br><br>
	109	32. In a linked list representation of a sparse matrix, what is the space complexity (in terms of nodes) for a dense matrix?	<br>	<b>1)</b>	a) O(n^2)	<b>2)</b>	b) O(n)	<b>3)</b>	c) O(1)	<b>4)</b>	d) O(n^3)	<b>Ans</b>	1	<br><br>
	110	33. In a circular linked list, the last node points to:	<br>	<b>1)</b>	The head node.	<b>2)</b>	NULL.	<b>3)</b>	The previous node.	<b>4)</b>	Any arbitrary node in the list.	<b>Ans</b>	1	<br><br>
	111	34. Which of the following statements is true about circular linked lists?	<br>	<b>1)</b>	They have a fixed size.	<b>2)</b>	"They do not have a fixed size.
	   
	"	<b>3)</b>	"They cannot be traverse  
	"	<b>4)</b>	They can only be singly linked.	<b>Ans</b>	2	<br><br>
	112	"35. Consider the following C code snippet to insert a node at the beginning of a circular linked list:
	 
	   void InsertBeginning(int value) {
		   Node* newNode = CreateNode(value);
		   if (head == NULL) {
			   newNode->next = newNode;
			   head = newNode;
		   } else {
			   newNode->next = head->next;
			   head->next = newNode;
		   }
	   }
	   What does this function do?
	"	<br>	<b>1)</b>	Inserts a node at the beginning of the circular linked list.	<b>2)</b>	Inserts a node at the end of the circular linked list.	<b>3)</b>	Deletes the first node in the circular linked list.	<b>4)</b>	Prints the circular linked list.	<b>Ans</b>	1	<br><br>
	113	"36. Consider the following C code snippet to delete the last node from a circular linked list:
	   void DeleteLast() {
		   if (head != NULL) {
			   if (head->next == hea{
				   free(head);
				   head = NULL;
			   } else {
				   Node* current = head;
				   while (current->next->next != hea{
					   current = current->next;
				   }
				   Node* temp = current->next;
				   current->next = head;
				   free(temp);
			   }
		   }
	   }
	   What is the purpose of the condition `if (head->next == head)`?
	36. Consider the following C code snippet to delete the last node from a circular linked list:
	   void DeleteLast() {
		   if (head != NULL) {
			   if (head->next == hea{
				   free(head);
				   head = NULL;
			   } else {
				   Node* current = head;
				   while (current->next->next != hea{
					   current = current->next;
				   }
				   Node* temp = current->next;
				   current->next = head;
				   free(temp);
			   }
		   }
	   }
	   What is the purpose of the condition `if (head->next == head)`?
	"	<br>	<b>1)</b>	It checks if the circular linked list contains only one node.	<b>2)</b>	It checks if the circular linked list is empty.	<b>3)</b>	It ensures that the last node is being deleted.	<b>4)</b>	It checks if the head pointer is not null.	<b>Ans</b>	1	<br><br>
	114	37. In a circular linked list, how do you identify that you have traversed the entire list?	<br>	<b>1)</b>	When you reach a node with a specific value.	<b>2)</b>	When you reach the head node again.	<b>3)</b>	When you encounter a NULL pointer.	<b>4)</b>	When you reach the last node.	<b>Ans</b>	2	<br><br>
	115	38. What is an advantage of using a circular linked list over a linear linked list?	<br>	<b>1)</b>	Circular linked lists use less memory.	<b>2)</b>	Circular linked lists allow for constant time insertion at the end.	<b>3)</b>	Circular linked lists have faster traversal.	<b>4)</b>	Circular linked lists can be used for storing large data sets.	<b>Ans</b>	2	<br><br>
	116	39. Which of the following is NOT a common application of circular linked lists?	<br>	<b>1)</b>	Music or media playlists.	<b>2)</b>	Navigation systems in vehicles.	<b>3)</b>	Process scheduling in operating systems.	<b>4)</b>	Stacks and queues.	<b>Ans</b>	4	<br><br>
	117	"40. Consider the following C code snippet to traverse a circular linked list:
	 
	   void TraverseList() {
		   if (head != NULL) {
			   Node* current = head;
			   do {
				   printf(""%d "", current->value);
				   current = current->next;
			   } while (current != head);
		   }
	   }
		 What does the `do-while` loop ensure?
	"	<br>	<b>1)</b>	It ensures that the traversal is done at least once.	<b>2)</b>	It ensures that the traversal is done exactly once.	<b>3)</b>	It ensures that the traversal stops at the head node.	<b>4)</b>	It ensures that the traversal is done in reverse.	<b>Ans</b>	3	<br><br>
	118	"41. Consider the following C code snippet to delete the first node from a circular linked list:
	   void DeleteFirst() {
		   if (head != NULL) {
			   if (head->next == hea{
				   free(head);
				   head = NULL;
			   } else {
				   Node* temp = head->next;
				   head->next = temp->next;
				   free(temp);
			   }
		   }
	   }
	   What does this function do?
	"	<br>	<b>1)</b>	Deletes the first node from a non-empty circular linked list.	<b>2)</b>	Deletes the first node from an empty circular linked list.	<b>3)</b>	Deletes the last node from a non-empty circular linked list.	<b>4)</b>	Deletes the last node from an empty circular linked list.	<b>Ans</b>	1	<br><br>
	119	42. What is a key feature of a circular doubly linked list compared to a circular singly linked list?	<br>	<b>1)</b>	Each node points to both the next and previous nodes.	<b>2)</b>	Each node points to the next node only.	<b>3)</b>	It has a fixed size.	<b>4)</b>	It allows constant time insertion at any position.	<b>Ans</b>	1	<br><br>
	120	43. In a doubly linked list, each node contains how many pointers?	<br>	<b>1)</b>	one	<b>2)</b>	two	<b>3)</b>	three	<b>4)</b>	four	<b>Ans</b>	2	<br><br>
	121	44. Which of the following statements is true about doubly linked lists?	<br>	<b>1)</b>	a) They can only be traversed in one direction.	<b>2)</b>	b) They can be traversed in both directions.	<b>3)</b>	c) They have a fixed size.	<b>4)</b>	d) They cannot be used to implement a queue.	<b>Ans</b>	2	<br><br>
	122	"45. Consider the following C code snippet to insert a node at the end of a doubly linked list:
	   void InsertEnd(int value) {
		   Node* newNode = CreateNode(value);
		   if (head == NULL) {
			   head = newNode;
		   } else {
			   Node* current = head;
			   while (current->next != NULL) {
				   current = current->next;
			   }
			   current->next = newNode;
			   newNode->prev = current;
		   }
	   }
	   What does this function do?
	"	<br>	<b>1)</b>	a. a) Inserts a node at the beginning of the doubly linked list.	<b>2)</b>	b. b) Inserts a node at the end of the doubly linked list.	<b>3)</b>	c. c) Deletes the first node in the doubly linked list.	<b>4)</b>	d. d) Prints the doubly linked list.	<b>Ans</b>	1	<br><br>
	123	"46. Consider the following C code snippet to delete the first node from a doubly linked list:
	   void DeleteFirst() {
		   if (head != NULL) {
			   Node* temp = head;
			   head = head->next;
			   if (head != NULL) {
				   head->prev = NULL;
			   }
			   free(temp);
		   }
	   }
	   What is the purpose of the condition `if (head != NULL)`?
	"	<br>	<b>1)</b>	a) It checks if the doubly linked list contains only one node.	<b>2)</b>	b) It checks if the doubly linked list is empty.	<b>3)</b>	c) It ensures that the last node is being deleted.	<b>4)</b>	d) It checks if the head pointer is not null.	<b>Ans</b>	1	<br><br>
	124	47. In a doubly linked list, how do you find the last node?	<br>	<b>1)</b>	a) Traverse from the head to the end of the list.	<b>2)</b>	b) Traverse from the end of the list to the head.	<b>3)</b>	c) Use the `tail` pointer.	<b>4)</b>	d) There is no way to find the last node.	<b>Ans</b>	1	<br><br>
	125	48. What is an advantage of using a doubly linked list over a singly linked list?	<br>	<b>1)</b>	a) It requires less memory.	<b>2)</b>	b) It allows for faster traversal.	<b>3)</b>	c) It allows for backward traversal.	<b>4)</b>	d) It can only be used for linear data structures.	<b>Ans</b>	3	<br><br>
	126	49. Which of the following is NOT a common application of doubly linked lists?	<br>	<b>1)</b>	 a) Implementing a text editor with undo/redo functionality.	<b>2)</b>	 b) Navigating forward and backward in a web browser.	<b>3)</b>	 c) Implementing a queue.	<b>4)</b>	 d) Implementing a music playlist.	<b>Ans</b>	3	<br><br>
	127	"50. Consider the following C code snippet to traverse a doubly linked list:
	   void TraverseList() {
		   Node* current = head;
		   while (current != NULL) {
			   printf(""%d "", current->value);
			   current = current->next;
		   }
	   }
	   What does this function do?
	"	<br>	<b>1)</b>	a) It traverses the doubly linked list from head to tail.	<b>2)</b>	b) It traverses the doubly linked list from tail to head.	<b>3)</b>	c) It reverses the doubly linked list.	<b>4)</b>	d) It deletes all nodes in the list.	<b>Ans</b>	1	<br><br>
	128	"51. Consider the following C code snippet to insert a node at the beginning of a doubly linked list:
	   void InsertBeginning(int value) {
		   Node* newNode = CreateNode(value);
		   if (head == NULL) {
			   head = newNode;
		   } else {
			   newNode->next = head;
			   head->prev = newNode;
			   head = newNode;
		   }
	   }
	   What does this function do?
	"	<br>	<b>1)</b>	a) Inserts a node at the beginning of a non-empty doubly linked list.	<b>2)</b>	b) Inserts a node at the beginning of an empty doubly linked list.	<b>3)</b>	c) Inserts a node at the end of a doubly linked list.	<b>4)</b>	d) Deletes the first node in the doubly linked list.	<b>Ans</b>	2	<br><br>
	129	"52. Consider the following C code snippet to delete the last node from a doubly linked list:
		void DeleteLast() {
			if (head != NULL) {
				Node* current = head;
				while (current->next != NULL) {
					current = current->next;
				}
				if (current->prev != NULL) {
					current->prev->next = NULL;
				} else {
					head = NULL;
				}
				free(current);
			}
		}
		What does this function do?
	"	<br>	<b>1)</b>	a) Deletes the last node from a non-empty doubly linked list.	<b>2)</b>	b) Deletes the first node from a non-empty doubly linked list.	<b>3)</b>	c) Deletes the last node from an empty doubly linked list.	<b>4)</b>	d) Deletes the first node from an empty doubly linked list.	<b>Ans</b>	1	<br><br>
	130	A circular linked list used for	<br>	<b>1)</b>	Stack	<b>2)</b>	Queue	<b>3)</b>	Both Stack & Queue	<b>4)</b>	Neither Stack or Queue	<b>Ans</b>	3	<br><br>
	131	In doubly linked lists 	<br>	<b>1)</b>	a pointer is maintained to store both next and previous nodes.	<b>2)</b>	two pointers are maintained to store next and previous nodes.	<b>3)</b>	a pointer to self is maintained for each node.	<b>4)</b>	none of the above.	<b>Ans</b>	2	<br><br>
	132	Each node in a linked list has two pairs of	<br>	<b>1)</b>	Link field and information field	<b>2)</b>	Link field and avail field	<b>3)</b>	Avail field and information field	<b>4)</b>	Address field and link field	<b>Ans</b>	1	<br><br>
	133	The disadvantage in using a circular linked list is …………………….	<br>	<b>1)</b>	It is possible to get into infinite loop	<b>2)</b>	Last node points to first node.	<b>3)</b>	Time consuming	<b>4)</b>	Requires more memory space	<b>Ans</b>	1	<br><br>
	134	A linear list in which each node has pointers to point to the predecessor and successors nodes is called as	<br>	<b>1)</b>	Singly Linked List	<b>2)</b>	Circular Linked List	<b>3)</b>	Doubly Linked List	<b>4)</b>	Linear Linked List	<b>Ans</b>	3	<br><br>
	135	Linked lists are best suited	<br>	<b>1)</b>	for relatively permanent collections of data	<b>2)</b>	for the size of the structure and the data in the structure are constantly changing	<b>3)</b>	for both of above situation	<b>4)</b>	for none of above situation	<b>Ans</b>	2	<br><br>
	136	The situation when in a linked list START=NULL is	<br>	<b>1)</b>	underflow	<b>2)</b>	overflow	<b>3)</b>	housefull	<b>4)</b>	saturated	<b>Ans</b>	1	<br><br>
	137	In which of the following is two way list?	<br>	<b>1)</b>	grounded header list	<b>2)</b>	linked list with header and trailer nodes	<b>3)</b>	circular header list	<b>4)</b>	none of above	<b>Ans</b>	4	<br><br>
	138	. Which of the following is false about a doubly linked list?	<br>	<b>1)</b>	We can navigate in both the directions	<b>2)</b>	It requires more space than a singly linked list	<b>3)</b>	The insertion and deletion of a node take a bit longer	<b>4)</b>	 Implementing a doubly linked list is easier than singly linked list	<b>Ans</b>	4	<br><br>
	139	What is a memory efficient double linked list?	<br>	<b>1)</b>	Each node has only one pointer to traverse the list back and forth	<b>2)</b>	The list has breakpoints for faster traversal	<b>3)</b>	An auxiliary singly linked list acts as a helper list to traverse through the doubly linked list	<b>4)</b>	A doubly linked list that uses bitwise AND operator for storing addresses	<b>Ans</b>	1	<br><br>
	140	A linked list is a linear collection of homogeneous elements called______.	<br>	<b>1)</b>	Runtime	<b>2)</b>	Nodes	<b>3)</b>	Pointers	<b>4)</b>	None of the above	<b>Ans</b>	2	<br><br>
	141	Depending on what on what can a linked list be classified into various other types?	<br>	<b>1)</b>	The number of pointers in a node	<b>2)</b>	The purpose for which the pointers are maintained	<b>3)</b>	Both (a) and (b)	<b>4)</b>	None of the above	<b>Ans</b>	3	<br><br>
	142	In a singly-linked list (linear linked list), how many fields does each node consists of?	<br>	<b>1)</b>	One	<b>2)</b>	Three	<b>3)</b>	Two	<b>4)</b>	Zero	<b>Ans</b>	3	<br><br>
	143	The last node of the singly-linked list contains__________.	<br>	<b>1)</b>	Info	<b>2)</b>	NULL	<b>3)</b>	Next	<b>4)</b>	None of the above	<b>Ans</b>	2	<br><br>
	144	A linked list contains a list pointer variable _____that stores the address of the first node of the list.	<br>	<b>1)</b>	Start	<b>2)</b>	NULL	<b>3)</b>	NULL	<b>4)</b>	Empty list	<b>Ans</b>	1	<br><br>
	145	Which of the following is two way list?	<br>	<b>1)</b>	grounded header list	<b>2)</b>	linked list with header and trailer nodes	<b>3)</b>	circular header list	<b>4)</b>	none of above	<b>Ans</b>	4	<br><br>
	146	What is a stack in data structures?	<br>	<b>1)</b>	A linear data structure	<b>2)</b>	A non-linear data structure	<b>3)</b>	A hierarchical data structure	<b>4)</b>	A tree-based data structure	<b>Ans</b>	1	<br><br>
	147	Which of the following best describes the Last-In-First-Out (LIFO) property of a stack?	<br>	<b>1)</b>	The first element added is the first element removed.	<b>2)</b>	The last element added is the first element removed	<b>3)</b>	.    The middle element is removed first.	<b>4)</b>	Elements can be removed in any order	<b>Ans</b>	2	<br><br>
	148	Which operation in a stack allows you to add an element to the top?	<br>	<b>1)</b>	Push	<b>2)</b>	Pop	<b>3)</b>	Top	<b>4)</b>	Peek	<b>Ans</b>	1	<br><br>
	149	In a stack, which operation allows you to remove an element from the top?	<br>	<b>1)</b>	Push	<b>2)</b>	Pop	<b>3)</b>	Top	<b>4)</b>	Peek	<b>Ans</b>	2	<br><br>
	150	What is the result of applying a `pop` operation on an empty stack?	<br>	<b>1)</b>	Stack Underflow	<b>2)</b>	Stack Overflow	<b>3)</b>	Empty Stack Exception	<b>4)</b>	No operation is performed	<b>Ans</b>	1	<br><br>
	151	Which operation in a stack allows you to view the top element without removing it?	<br>	<b>1)</b>	Push	<b>2)</b>	Pop	<b>3)</b>	Top	<b>4)</b>	Peek	<b>Ans</b>	4	<br><br>
	152	What is the time complexity of the `push` and `pop` operations in a stack implemented using an array?	<br>	<b>1)</b>	.    O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	O(n^2)	<b>Ans</b>	1	<br><br>
	153	Which of the following data structures is NOT suitable for implementing a stack?	<br>	<b>1)</b>	Array	<b>2)</b>	Linked List	<b>3)</b>	 Queue	<b>4)</b>	Circular Buffer	<b>Ans</b>	3	<br><br>
	154	Which application is NOT a common use of stacks?	<br>	<b>1)</b>	Expression evaluation	<b>2)</b>	Function call management	<b>3)</b>	Depth-First Search (DFS)	<b>4)</b>	Sorting	<b>Ans</b>	4	<br><br>
	155	In a web browser, which data structure is often used to implement the "Back" button functionality?	<br>	<b>1)</b>	Stack	<b>2)</b>	Queue	<b>3)</b>	Linked List	<b>4)</b>	Tree	<b>Ans</b>	1	<br><br>
	156	What is the result of applying a `pop` operation on an empty stack in a dynamically resizing stack implementation?	<br>	<b>1)</b>	Stack Underflow	<b>2)</b>	Stack Overflow	<b>3)</b>	Empty Stack Exception	<b>4)</b>	The stack capacity is increased	<b>Ans</b>	1	<br><br>
	157	Which of the following is a common application of the "min-stack" technique?	<br>	<b>1)</b>	Finding the minimum value in a stack in constant time	<b>2)</b>	Sorting elements in a stack	<b>3)</b>	Implementing a queue	<b>4)</b>	Evaluating postfix expressions	<b>Ans</b>	1	<br><br>
	158	In terms of space complexity, which implementation is more memory-efficient for a stack?	<br>	<b>1)</b>	Linked list-based implementation	<b>2)</b>	Array-based implementation	<b>3)</b>	Both have the same space complexity	<b>4)</b>	None	<b>Ans</b>	2	<br><br>
	159	What is the space complexity of a stack in the worst-case scenario for a linked list-based implementation?	<br>	<b>1)</b>	.     O(n)	<b>2)</b>	O(1)	<b>3)</b>	O(log n)	<b>4)</b>	.    O(n^2)	<b>Ans</b>	1	<br><br>
	160	Which type of memory allocation is suitable for implementing a stack?	<br>	<b>1)</b>	Static allocation	<b>2)</b>	Dynamic allocation	<b>3)</b>	Heap allocation	<b>4)</b>	None	<b>Ans</b>	1	<br><br>
	161	Which data structure is commonly used in recursive algorithms to keep track of function calls?	<br>	<b>1)</b>	Stack	<b>2)</b>	Queue	<b>3)</b>	Linked List	<b>4)</b>	Heap	<b>Ans</b>	1	<br><br>
	162	Consider the following C code snippet for initializing a stack using an array:    #define MAX_SIZE 10  int stack[MAX_SIZE];int top = -1;What does `MAX_SIZE` represent in this code?	<br>	<b>1)</b>	Maximum number of elements the stack can hold.	<b>2)</b>	Current number of elements in the stack.	<b>3)</b>	Index of the top element in the stack.	<b>4)</b>	Minimum number of elements the stack can hold.	<b>Ans</b>	1	<br><br>
	163	Which operation in a stack implemented using an array corresponds to pushing an element onto the stack?	<br>	<b>1)</b>	`push()`	<b>2)</b>	`pop()`	<b>3)</b>	   `peek()`	<b>4)</b>	   `enqueue()`	<b>Ans</b>	1	<br><br>
	164	In a stack implemented using an array, if `top` is initially set to `-1`, what does it signify?	<br>	<b>1)</b>	The stack is empty.	<b>2)</b>	The stack is full.	<b>3)</b>	The stack contains one element.	<b>4)</b>	The stack is at its maximum size.	<b>Ans</b>	1	<br><br>
	165	What is the time complexity of the `push` and `pop` operations in a stack implemented using an array?	<br>	<b>1)</b>	.    O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	.    O(n^2)	<b>Ans</b>	1	<br><br>
	166	"Consider the following C code snippet for initializing a stack using a linked list:
	   typedef struct Node {
		   int data;
		   struct Node* next;
	   } Node;
	
	   Node* top = NULL;
	   What is the purpose of the `next` pointer in the `Node` structure?
	"	<br>	<b>1)</b>	It points to the previous node in the stack.	<b>2)</b>	It points to the next node in the stack.	<b>3)</b>	It contains the data of the top element	<b>4)</b>	It points to the head of the linked list.	<b>Ans</b>	1	<br><br>
	167	. In a stack implemented using a linked list, if `top` is initially set to `NULL`, what does it signify?	<br>	<b>1)</b>	The stack is empty.	<b>2)</b>	  The stack is full.	<b>3)</b>	The stack contains one element.	<b>4)</b>	The stack is at its maximum size.	<b>Ans</b>	1	<br><br>
	168	Consider the following C code snippet for pushing an element onto the stack:	<br>	<b>1)</b>	It checks if the stack is empty.	<b>2)</b>	It checks if memory allocation for a new node is successful.	<b>3)</b>	It checks if the stack is full.	<b>4)</b>	It checks if the top element is less than the maximum size.	<b>Ans</b>	2	<br><br>
	169	What is the time complexity of the `push` and `pop` operations in a stack implemented using a linked list?	<br>	<b>1)</b>	O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	O(n^2)	<b>Ans</b>	1	<br><br>
	170	In infix notation, the operator precedence rules state that:	<br>	<b>1)</b>	Operators of higher precedence are evaluated first.	<b>2)</b>	Operators of lower precedence are evaluated first.	<b>3)</b>	All operators are evaluated from left to right.	<b>4)</b>	Parentheses determine the order of evaluation.	<b>Ans</b>	1	<br><br>
	171	Consider the infix expression: `A + B * C - D / E`. What is the corresponding postfix expression?	<br>	<b>1)</b>	`A B C * + D E / -`	<b>2)</b>	`A B C D E / - + *`	<b>3)</b>	`A B + C D E - / *`	<b>4)</b>	`A B C D E / - + *`	<b>Ans</b>	1	<br><br>
	172	In the Shunting Yard algorithm, which data structure is typically used to store operators and operands?	<br>	<b>1)</b>	Stack	<b>2)</b>	Queue	<b>3)</b>	Linked List	<b>4)</b>	Array	<b>Ans</b>	1	<br><br>
	173	What is the result of evaluating the postfix expression `5 3 * 8 +`?	<br>	<b>1)</b>	23	<b>2)</b>	15	<b>3)</b>	14	<b>4)</b>	24	<b>Ans</b>	2	<br><br>
	174	Which operator in postfix notation performs exponentiation?	<br>	<b>1)</b>	`^`	<b>2)</b>	`*`	<b>3)</b>	`/`	<b>4)</b>	 `+`	<b>Ans</b>	1	<br><br>
	175	Consider the postfix expression: `4 2 ^ 3 5 * +`. What is the result of the evaluation?	<br>	<b>1)</b>	31	<b>2)</b>	43	<b>3)</b>	53	<b>4)</b>	35	<b>Ans</b>	1	<br><br>
	176	In postfix evaluation, when an operand is encountered, it is:	<br>	<b>1)</b>	Pushed onto the stack.	<b>2)</b>	Popped from the stack	<b>3)</b>	Ignored.	<b>4)</b>	Checked for precedence.	<b>Ans</b>	1	<br><br>
	177	Given the infix expression: `A * (B + / D - E`, what is the corresponding postfix expression?	<br>	<b>1)</b>	`A B C + * D / E -`	<b>2)</b>	 `A B C + D * E - /`	<b>3)</b>	`A B C + D / * E -`	<b>4)</b>	.    `A B C + D E - * /`	<b>Ans</b>	1	<br><br>
	178	Consider the postfix expression: `8 4 6 * + 3 2 * +`. What is the result of the evaluation?	<br>	<b>1)</b>	36	<b>2)</b>	28	<b>3)</b>	18	<b>4)</b>	14	<b>Ans</b>	2	<br><br>
	179	What is a queue in data structures?	<br>	<b>1)</b>	A linear data structure	<b>2)</b>	A non-linear data structure	<b>3)</b>	A hierarchical data structure	<b>4)</b>	A tree-based data structure	<b>Ans</b>	1	<br><br>
	180	Which of the following best describes the First-In-First-Out (FIFO) property of a queue?	<br>	<b>1)</b>	The first element added is the first element removed.	<b>2)</b>	The last element added is the first element removed.	<b>3)</b>	Elements can be removed in any order.	<b>4)</b>	Elements are removed in reverse order of insertion.	<b>Ans</b>	1	<br><br>
	181	Which operation in a queue allows you to add an element at the end?	<br>	<b>1)</b>	Enqueue	<b>2)</b>	Dequeue	<b>3)</b>	Front	<b>4)</b>	Peek	<b>Ans</b>	1	<br><br>
	182	In a queue, which operation allows you to remove an element from the front?	<br>	<b>1)</b>	Enqueue	<b>2)</b>	Dequeue	<b>3)</b>	Front	<b>4)</b>	Peek	<b>Ans</b>	2	<br><br>
	183	What is the result of applying a `dequeue` operation on an empty queue?	<br>	<b>1)</b>	Queue Underflow	<b>2)</b>	Queue Overflow	<b>3)</b>	Empty Queue Exception	<b>4)</b>	No operation is performed	<b>Ans</b>	1	<br><br>
	184	Which operation in a queue allows you to view the front element without removing it?	<br>	<b>1)</b>	Enqueue	<b>2)</b>	Dequeue	<b>3)</b>	Front	<b>4)</b>	Peek	<b>Ans</b>	3	<br><br>
	185	What is the time complexity of the `enqueue` and `dequeue` operations in a queue implemented using an array?	<br>	<b>1)</b>	O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	O(n^2)	<b>Ans</b>	1	<br><br>
	186	Which of the following data structures is NOT suitable for implementing a queue?	<br>	<b>1)</b>	Array	<b>2)</b>	Linked List	<b>3)</b>	Stack	<b>4)</b>	Binary Search Tree	<b>Ans</b>	4	<br><br>
	187	Which application is NOT a common use of queues?	<br>	<b>1)</b>	Process scheduling in operating systems	<b>2)</b>	Print spooling	<b>3)</b>	Breadth-First Search (BFS)	<b>4)</b>	Expression evaluation	<b>Ans</b>	4	<br><br>
	188	In a web server, which data structure is often used to manage incoming HTTP requests?	<br>	<b>1)</b>	Queue	<b>2)</b>	Stack	<b>3)</b>	Linked List	<b>4)</b>	Tree	<b>Ans</b>	1	<br><br>
	189	What is a key characteristic of a priority queue?	<br>	<b>1)</b>	Elements are removed in the order they were added.	<b>2)</b>	Elements have a priority associated with them.	<b>3)</b>	Elements can be added at any position.	<b>4)</b>	It uses a LIFO approach for element removal.	<b>Ans</b>	2	<br><br>
	190	What is a key feature of a circular queue compared to a regular queue?	<br>	<b>1)</b>	It has a fixed size.	<b>2)</b>	Elements can be added or removed at any position.	<b>3)</b>	It has no front or rear.	<b>4)</b>	It efficiently uses memory space.	<b>Ans</b>	4	<br><br>
	191	Consider the following C code snippet for initializing a queue using an array:	<br>	<b>1)</b>	Maximum number of elements the queue can hold.	<b>2)</b>	Current number of elements in the queue.	<b>3)</b>	Index of the front element in the queue.	<b>4)</b>	Minimum number of elements the queue can hold.	<b>Ans</b>	4	<br><br>
	192	Which operation in a queue implemented using an array corresponds to adding an element at the rear?	<br>	<b>1)</b>	Enqueue	<b>2)</b>	Dequeue	<b>3)</b>	Front	<b>4)</b>	Peek	<b>Ans</b>	1	<br><br>
	193	In a queue implemented using an array, if `front` and `rear` are initially set to `-1`, what does it signify?	<br>	<b>1)</b>	The queue is empty.	<b>2)</b>	The queue is full.	<b>3)</b>	The queue contains one element.	<b>4)</b>	The queue is at its maximum size.	<b>Ans</b>	1	<br><br>
	194	"Consider the following C code snippet for adding an element to the rear of the queue:
	   void enqueue(int element) {
		   Node* newNode = (Node*)malloc(sizeof(Node));
		   if (newNode != NULL) {
			   newNode->data = element;
			   newNode->next = NULL;
			   if (rear == NULL) {
				   front = newNode;
			   } else {
				   rear->next = newNode;
			   }
			   rear = newNode;
		   } else {
			   printf(""Memory allocation failed\n"");
		   }
	   }
	   What is the purpose of the condition `if (newNode != NULL)`?"	<br>	<b>1)</b>	It checks if the queue is empty.	<b>2)</b>	It checks if the queue is full.	<b>3)</b>	It ensures that the front index is updated.	<b>4)</b>	It ensures that the rear index is within bounds.	<b>Ans</b>	2	<br><br>
	195	What is the time complexity of the `enqueue` and `dequeue` operations in a queue implemented using an array?	<br>	<b>1)</b>	O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	O(n^2)	<b>Ans</b>	1	<br><br>
	196	Consider the following C code snippet for initializing a queue using a linked list:	<br>	<b>1)</b>	It points to the previous node in the queue.	<b>2)</b>	It points to the next node in the queue.	<b>3)</b>	It contains the data of the front element.	<b>4)</b>	It points to the head of the linked list.	<b>Ans</b>	2	<br><br>
	197	Which operation in a queue implemented using a linked list corresponds to adding an element at the rear?	<br>	<b>1)</b>	Enqueue	<b>2)</b>	Dequeue	<b>3)</b>	Front	<b>4)</b>	Peek	<b>Ans</b>	1	<br><br>
	198	In a queue implemented using a linked list, if both `front` and `rear` are initially set to `NULL`, what does it signify?	<br>	<b>1)</b>	The queue is empty.	<b>2)</b>	The queue is full.	<b>3)</b>	The queue contains one element.	<b>4)</b>	The queue is at its maximum size.	<b>Ans</b>	1	<br><br>
	199	"Consider the following C code snippet for adding an element to the rear of the queue:
	   void enqueue(int element) {
		   Node* newNode = (Node*)malloc(sizeof(Node));
		   if (newNode != NULL) {
			   newNode->data = element;
			   newNode->next = NULL;
			   if (rear == NULL) {
				   front = newNode;
			   } else {
				   rear->next = newNode;
			   }
			   rear = newNode;
		   } else {
			   printf(""Memory allocation failed\n"");
		   }
	   }
	   What is the purpose of the condition `if (newNode != NULL)`?"	<br>	<b>1)</b>	It checks if the queue is empty.	<b>2)</b>	It checks if memory allocation for a new node is successful.	<b>3)</b>	It checks if the queue is full.	<b>4)</b>	It checks if the rear pointer is not null.	<b>Ans</b>	2	<br><br>
	200	What is the time complexity of the `enqueue` and `dequeue` operations in a queue implemented using a linked list?	<br>	<b>1)</b>	O(1)	<b>2)</b>	O(log n)	<b>3)</b>	O(n)	<b>4)</b>	O(n^2)	<b>Ans</b>	1	<br><br>
	</blockquote>
</body>
</html>
